---
description: Guide for migrating Swift code to Swift 6 with concurrency and strict checking
globs: "**/*.swift"
alwaysApply: false
---

================================================
FILE: README.md
================================================
# Swift 동시성 마이그레이션 가이드

이 저장소는 [Swift-DocC][docc]를 사용하여 구축된 [Swift 동시성 마이그레이션 가이드][scmg]의 소스를 포함합니다.

## 기여하기

Swift 마이그레이션 가이드에 기여하는 방법에 대한 지침은 [기여 가이드][contributing]를 참조하세요.

## 빌드하기

이 저장소의 루트 디렉터리에서 `docc preview Guide.docc`를 실행하세요.

DocC 실행 후, `docc`가 출력하는 링크를 열어 브라우저에서 로컬 미리보기를 표시하세요.

> 참고:
>
> Swift.org에서 툴체인을 다운로드하여 DocC를 설치한 경우,
> `docc`는 툴체인 설치 경로를 기준으로 `usr/bin/`에 위치합니다.
> 셸의 `PATH` 환경 변수가 해당 디렉터리를 포함하는지 확인하세요.
>
> Xcode를 다운로드하여 DocC를 설치한 경우,
> 대신 `xcrun docc`를 사용하세요.

[contributing]: https://github.com/apple/swift-migration-guide/blob/main/CONTRIBUTING.md
[docc]: https://github.com/apple/swift-docc
[conduct]: https://www.swift.org/code-of-conduct
[scmg]: https://www.swift.org/migration/documentation/migrationguide


================================================
FILE: CODEOWNERS
================================================
# '#'로 시작하는 줄은 주석입니다.
# 각 줄은 대소문자를 구분하는 파일 패턴과 하나 이상의 소유자로 구성됩니다.
# 순서가 중요합니다. 마지막으로 일치하는 패턴이 가장 높은 우선순위를 가집니다.
# 자세한 정보: https://docs.github.com/en/articles/about-code-owners
#
# 대소문자를 구분하는 사전순으로 저장소의 파일 계층 구조를 미러링하세요.

* @hborla @mattmassicotte @shahmishal @ktoso


================================================
FILE: CONTRIBUTING.md
================================================
# Swift 마이그레이션 가이드에 기여하기

## Swift 커뮤니티에 오신 것을 환영합니다!

Swift 프로젝트에 대한 기여를 환영하고 격려합니다!
[Swift에 기여하기 가이드](https://www.swift.org/contributing/)를 참조하고
커뮤니티의 구조를 확인하세요.

진정으로 훌륭한 커뮤니티가 되기 위해서는 Swift는 모든 계층의 개발자들을
환영해야 하며, 다양한 배경과 광범위한 경험을 가진 개발자들이 필요합니다.
다양하고 친화적인 커뮤니티는 더 많은 훌륭한 아이디어와 더 독특한 관점을 가지고
더 훌륭한 코드를 생산할 것입니다. 우리는 Swift 커뮤니티가 모든 사람을 환영하는
곳이 되도록 부지런히 노력할 것입니다.

우리 멤버들에게 기대되는 바를 명확히 하기 위해, Swift는 Contributor Covenant에서
정의한 행동 강령을 채택했습니다. 이 문서는 많은 오픈 소스 커뮤니티에서
사용되고 있으며, 우리의 가치를 잘 표현한다고 생각합니다.
자세한 내용은 [행동 강령](https://www.swift.org/code-of-conduct/)을 참조하세요.

## swift-migration-guide에 기여하기

### 도움을 주실 수 있는 방법

다음과 같은 형태의 기여를 환영합니다:
- 가이드의 특정 코드 패턴이나 추가 섹션을 다루는 이슈 제출
- 기존 콘텐츠를 개선하거나 새로운 콘텐츠를 추가하는 풀 리퀘스트 열기
- 글쓰기와 코드 예제의 명확성과 정확성을 위한 다른 사람들의 풀 리퀘스트 검토

### 이슈 및 풀 리퀘스트 제출

#### 이슈

Github의 [이슈 페이지][bugs]를 사용하여 콘텐츠에 대한 버그를 제출하세요.

#### 풀 리퀘스트 열기

풀 리퀘스트를 생성하려면 이 저장소를 포크하고, 변경사항을 브랜치에 푸시한 후
`main` 브랜치에 대한 풀 리퀘스트를 여세요.

#### 빌드 및 테스트

이 저장소의 루트 디렉터리에서 `docc preview Guide.docc`를 실행하세요.

DocC 실행 후, `docc`가 출력하는 링크를 열어 브라우저에서 로컬 미리보기를 표시하세요.

> 참고:
>
> Swift.org에서 툴체인을 다운로드하여 DocC를 설치한 경우,
> `docc`는 툴체인 설치 경로를 기준으로 `usr/bin/`에 위치합니다.
> 셸의 `PATH` 환경 변수가 해당 디렉터리를 포함하는지 확인하세요.
>
> Xcode를 다운로드하여 DocC를 설치한 경우,
> 대신 `xcrun docc`를 사용하세요.

#### CI 실행

변경사항이 병합되기 전에 풀 리퀘스트는 `@swift-ci please test`를 통해 CI 테스트를 통과해야 합니다.

### PR 검토 받기

풀 리퀘스트를 열면 검토자가 자동으로 태그됩니다. 코드 검토 중에 변경을 요청받을 수 있습니다.
준비가 되면 github의 재검토 요청 기능을 사용하거나 댓글에서 검토자의 이름을 언급하세요.

[bugs]: https://github.com/apple/swift-migration-guide/issues

================================================
FILE: LICENSE.txt
================================================
                                 Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

사용, 복제 및 배포에 대한 이용 약관

1. 정의.

   "라이센스"는 이 문서의 섹션 1부터 9까지에서 정의된 사용, 복제 및 배포에 대한 이용 약관을 의미합니다.

   "라이센서"는 라이센스를 부여하는 저작권 소유자 또는 저작권 소유자가 승인한 엔티티를 의미합니다.

   "법적 엔티티"는 실행 엔티티와 해당 엔티티를 제어하거나, 제어를 받거나, 공통 제어 하에 있는 기타 모든 엔티티의 연합을 의미합니다.
   이 정의의 목적상, "제어"는 (i) 계약 또는 기타 방법으로 해당 엔티티의 지시나 관리를 직접 또는 간접적으로 야기할 수 있는 권한,
   또는 (ii) 발행주식의 50% 이상의 소유권, 또는 (iii) 해당 엔티티의 수익적 소유권을 의미합니다.

   "귀하"(또는 "귀하의")는 이 라이센스에 의해 부여된 권한을 행사하는 개인 또는 법적 엔티티를 의미합니다.

   "소스" 형태는 소프트웨어 소스 코드, 문서 소스 및 구성 파일을 포함하되 이에 국한되지 않는 수정에 선호되는 형태를 의미합니다.

   "오브젝트" 형태는 컴파일된 오브젝트 코드, 생성된 문서 및 기타 미디어 유형으로의 변환을 포함하되 이에 국한되지 않는
   소스 형태의 기계적 변환 또는 번역으로 인한 모든 형태를 의미합니다.

   "작업"은 작업에 포함되거나 첨부된 저작권 고지로 표시되는 라이센스 하에서 사용할 수 있는 소스 또는 오브젝트 형태의 저작물을 의미합니다
   (아래 부록에 예제가 제공됨).

   "파생 작업"은 작업을 기반으로 하거나 작업에서 파생된 소스 또는 오브젝트 형태의 작업을 의미하며,
   편집 수정, 주석, 정교화 또는 기타 수정이 전체적으로 원본 저작물을 나타내는 경우를 말합니다.
   이 라이센스의 목적상, 파생 작업은 작업과 분리 가능하거나 작업 및 그 파생 작업의 인터페이스에 단순히 링크(또는 이름으로 바인딩)되는 작업을 포함하지 않습니다.

   "기여"는 작업의 원본 버전과 해당 작업 또는 파생 작업에 대한 수정 또는 추가를 포함하여
   저작권 소유자 또는 저작권 소유자를 대신하여 제출할 권한이 있는 개인 또는 법적 엔티티가
   라이센서에 작업에 포함하기 위해 의도적으로 제출한 모든 저작물을 의미합니다.
   이 정의의 목적상, "제출"은 작업을 논의하고 개선하기 위해 라이센서 또는 그 대표자에게 전송되는
   전자, 구두 또는 서면 통신을 의미하며, 여기에는 전자 메일링 리스트, 소스 코드 제어 시스템 및
   라이센서를 대신하여 관리되는 이슈 추적 시스템에서의 통신이 포함되지만,
   저작권 소유자가 서면으로 "기여가 아님"으로 명시적으로 표시하거나 지정한 통신은 제외됩니다.

   "기여자"는 라이센서와 라이센서가 기여를 받아 작업에 포함시킨 개인 또는 법적 엔티티를 의미합니다.

2. 저작권 라이센스 부여. 이 라이센스의 이용 약관에 따라, 각 기여자는 귀하에게 작업 및 해당 파생 작업을
   소스 또는 오브젝트 형태로 복제, 파생 작업 준비, 공개 전시, 공개 수행, 서브라이센스 및 배포할 수 있는
   영구적, 전세계적, 비독점적, 무료, 로열티 없는, 취소 불가능한 저작권 라이센스를 부여합니다.

[라이센스 내용 계속...]

================================================
FILE: Guide.docc/CommonProblems.md
================================================
# 일반적인 컴파일러 오류

Swift 동시성 작업 중 발생할 수 있는 일반적인 문제를 식별하고 이해하며 해결하는 방법을 알아보세요.

컴파일러가 제공하는 데이터 격리 보장은 모든 Swift 코드에 영향을 미칩니다.
이는 완전한 동시성 검사가 동시성 언어 기능을 직접 사용하지 않는 Swift 5 코드에서도
잠재적인 문제를 드러낼 수 있음을 의미합니다.
Swift 6 언어 모드가 활성화되면 이러한 잠재적 문제 중 일부가 오류가 될 수도 있습니다.

완전한 검사를 활성화한 후 많은 프로젝트에서 대량의 경고와 오류가 발생할 수 있습니다.
당황하지 마세요!
이러한 대부분은 훨씬 더 작은 근본 원인 집합으로 추적할 수 있습니다.
그리고 이러한 원인들은 종종 수정하기 쉬울 뿐만 아니라
Swift의 동시성 시스템을 학습하는 데 매우 유익한 일반적인 패턴의 결과입니다.

## 안전하지 않은 전역 및 정적 변수

정적 변수를 포함한 전역 상태는 프로그램의 어디서든 접근할 수 있습니다.
이러한 가시성은 동시 접근에 특히 취약하게 만듭니다.
데이터 레이스 안전성 이전에는 전역 변수 패턴이 프로그래머가
컴파일러의 도움 없이 데이터 레이스를 피하는 방식으로 전역 상태에 조심스럽게 접근하는 것에 의존했습니다.

> 실험: 이 코드 예제들은 패키지 형태로 제공됩니다.
[Globals.swift][Globals]에서 직접 시도해보세요.

[Globals]: https://github.com/apple/swift-migration-guide/blob/main/Sources/Examples/Globals.swift

### Sendable 타입

```swift
var supportedStyleCount = 42
```

여기서 전역 변수를 정의했습니다.
전역 변수는 격리되지 않으면서 어떤 격리 도메인에서든 변경 가능합니다.
Swift 6 모드에서 위 코드를 컴파일하면 다음과 같은 오류 메시지가 생성됩니다:

```
1 | var supportedStyleCount = 42
  |              |- error: global variable 'supportedStyleCount' is not concurrency-safe because it is non-isolated global shared mutable state
  |              |- note: convert 'supportedStyleCount' to a 'let' constant to make the shared state immutable
  |              |- note: restrict 'supportedStyleCount' to the main actor if it will only be accessed from the main thread
  |              |- note: unsafely mark 'supportedStyleCount' as concurrency-safe if all accesses are protected by an external synchronization mechanism
2 |
```

서로 다른 격리 도메인을 가진 두 함수가 이 변수에 접근하면 데이터 레이스 위험이 있습니다.
다음 코드에서 `printSupportedStyles()`는 메인 액터에서 실행되는 동안
`addNewStyle()`이 다른 격리 도메인에서 동시에 호출될 수 있습니다:

```swift
@MainActor
func printSupportedStyles() {
    print("지원되는 스타일: ", supportedStyleCount)
}

func addNewStyle() {
    let style = Style()

    supportedStyleCount += 1

    storeStyle(style)
}
```

이 문제를 해결하는 한 가지 방법은 변수의 격리를 변경하는 것입니다.

```swift
@MainActor
var supportedStyleCount = 42
```

변수는 여전히 변경 가능하지만 전역 액터에 격리되었습니다.
모든 접근은 이제 하나의 격리 도메인에서만 일어날 수 있으며,
`addNewStyle` 내의 동기 접근은 컴파일 시점에 유효하지 않습니다.

변수가 상수이며 변경되지 않는다면, 컴파일러에게 이를 표현하는 것이 간단한 해결책입니다.
`var`를 `let`으로 변경하면 컴파일러가 정적으로 변경을 허용하지 않아 안전한 읽기 전용 접근을 보장합니다.

```swift
let supportedStyleCount = 42
```

전역 값은 계산 프로퍼티로도 표현할 수 있습니다.
이러한 프로퍼티가 일관되게 동일한 상수 값을 반환한다면,
관찰 가능한 값/효과에 관한 한 `let` 상수와 의미상 동일합니다:

```swift
var supportedStyleCount: Int {
    42
}
```

이 변수를 컴파일러에게 보이지 않는 방식으로 보호하는 동기화가 있다면,
`nonisolated(unsafe)`를 사용하여 `supportedStyleCount`에 대한 모든 격리 검사를 비활성화할 수 있습니다.

```swift
/// 이 값은 `styleLock`을 보유하는 동안에만 접근됩니다.
nonisolated(unsafe) var supportedStyleCount = 42
```

변수에 대한 모든 접근을 락이나 디스패치 큐와 같은 외부 동기화 메커니즘으로 신중하게 보호하는 경우에만
`nonisolated(unsafe)`를 사용하세요.

### Non-Sendable 타입

위 예제에서 변수는 본질적으로 `Sendable`인 값 타입인 `Int`입니다.
전역 _참조_ 타입은 일반적으로 `Sendable`이 아니기 때문에 추가적인 도전을 제시합니다.

```swift
class WindowStyler {
    var background: ColorComponents

    static let defaultStyler = WindowStyler()
}
```

이 `static let` 선언의 문제는 변수의 변경 가능성과 관련이 없습니다.
문제는 `WindowStyler`가 non-`Sendable` 타입이라는 것으로, 내부 상태를 격리 도메인 간에 공유하는 것이 안전하지 않다는 것입니다.

이 예제는 계속해서 격리 도메인 간에 전달되고 다양한 동시성 문제를 다루는 긴 가이드의 일부입니다.

## 프로토콜 준수 격리 불일치

프로토콜은 정적 격리를 포함하여 준수 타입이 만족해야 하는 요구사항을 정의합니다.
이는 프로토콜의 선언과 준수 타입 간의 격리 불일치를 초래할 수 있습니다.

이 문제 클래스에 대한 많은 가능한 해결책이 있지만, 종종 트레이드오프를 포함합니다.
적절한 접근 방식을 선택하려면 먼저 _왜_ 불일치가 발생하는지 이해해야 합니다.

### 격리 경계 교차

컴파일러는 데이터 레이스를 야기하지 않을 것임을 증명할 수 있을 때만 
값이 한 격리 도메인에서 다른 격리 도메인으로 이동하는 것을 허용합니다.
격리 경계를 교차할 수 있는 컨텍스트에서 이 요구사항을 만족하지 않는 값을 사용하려고 시도하는 것은 매우 일반적인 문제입니다.

### 데이터 레이스 안전성

Swift 6 언어 모드는 컴파일 시점에 데이터 레이스를 방지하여 이러한 문제를 제거합니다.
이 시스템은 _데이터 격리_라는 메커니즘을 통해 작동합니다.

### 격리 도메인

데이터 격리는 공유 가변 상태를 보호하는 데 사용되는 _메커니즘_입니다.
하지만 독립적인 격리 단위에 대해 이야기하는 것이 유용할 때가 많습니다.
이를 _격리 도메인_이라고 합니다.

격리 도메인이 보호하는 상태의 양은 크게 다릅니다. 격리 도메인은 단일 변수를 보호할 수도 있고,
사용자 인터페이스와 같은 전체 하위 시스템을 보호할 수도 있습니다.

격리 도메인의 중요한 특징은 그것이 제공하는 안전성입니다.
가변 상태는 한 번에 하나의 격리 도메인에서만 접근할 수 있습니다.
가변 상태를 한 격리 도메인에서 다른 격리 도메인으로 전달할 수 있지만,
다른 도메인에서 해당 상태에 동시에 접근할 수는 없습니다.
이 보장은 컴파일러에 의해 검증됩니다.

[이 가이드는 Swift 6 마이그레이션에 대한 포괄적인 설명을 계속 제공합니다...]