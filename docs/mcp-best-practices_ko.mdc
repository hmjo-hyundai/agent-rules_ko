---
description: Model Context Protocol (MCP) 도구 개발을 위한 모범 사례, 적절한 구성 및 동작 방식
globs: "*.mcp, mcp-*/**"
alwaysApply: false
---

# MCP 모범 사례 - 2025년 5월 26일

**I. 일반 도구 구성 및 동작**

1.  **합리적인 기본값:** 모든 환경 변수는 즉시 사용 가능한 편리한 기본값을 가져야 합니다.
2.  **동적 버전 관리:** 도구의 버전은 설명에 표시됩니다. 이 버전은 하드코딩되지 않고 동적으로 (예: `package.json`에서) 읽어야 합니다.
3.  **도구 및 매개변수 설명:**
    *   **도구 제목:** 도구에 대해 설명적이고 사용자 친화적인 제목을 사용합니다.
    *   **매개변수 설명:** 모든 매개변수는 명확한 설명을 제공해야 합니다.
    *   **선택/필수 매개변수:** 매개변수는 "선택사항" 또는 "필수"로 명시적으로 표시되어야 합니다.
    *   **기본값:** 매개변수가 선택사항인 경우, 기본값을 설명해야 합니다.
    *   (이러한 세부 사항은 Cursor와 같은 클라이언트에서 도구에 마우스를 올리거나 MCP 인스펙터를 사용하여 확인할 수 있어야 합니다.)
4.  **매개변수 파싱:** 매개변수 파싱은 관대해야 합니다(예: `project_path`가 공식적으로 정의된 경우 `path`를 허용). 일반적으로 더 엄격한 스키마를 광고하되 에이전트의 변형을 수용하기 위해 실행 시에는 더 관대하게 처리해야 합니다.
5.  **런타임 오류 처리:** 오류가 발생한 경우, 잠재적으로 복구할 수 있는 정보와 함께 호출자에게 도움이 되는 메시지를 전송합니다.
6.  **구성 오류 처리:** 잘못된 구성(예: 잘못 설정된 환경 변수)은 도구를 중단시키지 않아야 합니다. 대신 도구가 실행될 때 유용한 설명을 제공하여 사용자가 설정을 스스로 수정할 수 있도록 합니다.
7.  **stdio 출력 금지:** **중요: 도구 작업 중에 stdout 또는 stderr로의 출력이 절대 없어야 합니다.** 여기에는 다음이 포함됩니다:
    *   `console.log()`, `console.error()`, `console.warn()` 등 금지
    *   `process.stdout.write()` 또는 `process.stderr.write()` 금지
    *   stdio로의 출력문이나 디버그 출력 금지
    *   오류나 초기화 중에도 모든 출력은 파일 로거를 통해야 함
    *   stdio 출력은 MCP 클라이언트(Claude 등)를 방해하고 로딩 오류를 발생시킴
    *   파일 기반 로깅(예: Pino로 로그 파일에 기록)만이 운영 출력의 유일한 허용 방법
8.  **`info` 명령:**
    *   최소 하나의 도구는 `info` 하위 명령을 제공해야 합니다(가장 적절한 도구를 찾아 추가)
    *   이 명령은 다음을 나열해야 합니다:
        *   MCP 도구의 버전
        *   필요한 네이티브 종속성의 상태(해당하는 경우), 존재 및 기능에 대한 테스트 포함
        *   감지된 구성 문제나 누락된 환경 변수(예: 로거 경로 문제)

**II. 로깅 (Pino)**

1.  **기본 파일 로거:** Pino는 시스템의 로그 디렉터리(예: `~/Library/Logs/`)에서 기본 파일 로거와 함께 로깅에 사용됩니다. 로그 파일 경로는 `[ProjectName]_LOG_FILE` 환경 변수를 통해 구성 가능합니다.
2.  **로그 경로 복원력:**
    *   Pino 로직은 지정된 로그 파일 경로에 대해 누락된 상위 디렉터리를 자동으로 생성해야 합니다.
    *   pino가 `[ProjectName]_LOG_FILE` 경로에 쓸 수 없는 경우, 기본 임시 디렉터리 경로로 로깅을 폴백해야 합니다.
3.  **구성 가능한 로그 레벨:** 로그 레벨은 `[ProjectName]_LOG_LEVEL` 환경 변수를 사용하여 설정됩니다(대문자, 소문자 또는 혼합 대소문자 값 허용).
4.  **선택적 콘솔 로깅:** 환경 변수 `[ProjectName]_CONSOLE_LOGGING=true`는 pino 파일 로거에 추가로 콘솔에도 로깅을 활성화합니다.
5.  **로거 플러시:** 모든 로그 메시지가 기록되도록 프로세스가 종료되기 전에 로거를 플러시해야 합니다.

**III. 코드, 종속성 및 빌드**

1.  **종속성 관리:** 모든 종속성은 최신 안정 버전으로 유지되어야 합니다. (릴리스 스크립트는 오래된 종속성에 대해 경고합니다).
2.  **정적 분석:** 린터(예: ESLint) 또는 TypeScript 오류가 없어야 합니다.
3.  **파일 크기:** 단일 파일은 500줄의 코드(LOC)를 초과하지 않아야 하며; 300 LOC 미만을 목표로 합니다.
4.  **컴파일된 코드로 실행:** 시작 로직과 모든 도구 작업은 항상 컴파일된 JavaScript 출력(예: `dist` 폴더에서)을 사용해야 합니다.
5.  **Shebang:** 직접 실행을 위한 컴파일된 JavaScript 파일에는 올바른 shebang(예: `#!/usr/bin/env node`)이 있어야 합니다.
6.  **NPM 패키지 내용:** 게시된 npm 패키지는 절대 최소 파일만 포함해야 합니다: `dist/` 폴더, 잠재적인 네이티브 구성 요소, `README.md`, 그리고 `LICENSE` 파일.

**IV. 테스팅**

1.  **테스트 프레임워크:** 테스트는 `vitest`를 사용해야 합니다.
2.  **TypeScript 테스트 스위트:** TypeScript 레이어에 대한 포괄적인 테스트 스위트가 필요합니다.
3.  **엔드 투 엔드(E2E) 테스트:** 완전한 설정을 검증하는 E2E 테스트가 필요합니다. (macOS 액세스와 같은 권한으로 인해 CI 실행이 어려운 경우 릴리스 준비로 실행될 수 있습니다).
4.  **NPM 스크립트:**
    *   `npm run prepare-release`는 포괄적인 테스트 스위트를 실행합니다(섹션 VI에서 자세히 설명).
    *   `npm run inspector`는 `npx @modelcontextprotocol/inspector node path/to/server/index.js`를 실행합니다.

**V. 네이티브 바이너리 규칙 (해당하는 경우)**

1.  **macOS 호환성:** 바이너리는 유니버설(Apple Silicon 및 Intel)이어야 하며 현재 macOS 버전과 이전 주요 버전(n-1, 예: 현재가 15인 경우 macOS >= 14)을 지원해야 합니다.
2.  **빌드 최적화:** 최소 바이너리 파일 크기를 달성하기 위해 컴파일러 및 링커 플래그를 설정해야 합니다.
3.  **네이티브 테스트 스위트:** Swift의 네이티브 테스팅 도구(예: `swift-test` 또는 XCTest)를 사용한 포괄적인 테스트 스위트가 필요합니다.
4.  **사용자 정의 경로 구성:** 환경 변수는 네이티브 바이너리를 실행하기 위한 사용자 정의 절대 경로 설정을 허용해야 합니다.
5.  **오류 통신:** 도구가 네이티브 라이브러리를 사용하는 경우, `errno`(또는 동등한 메커니즘)를 사용하여 오류 및 실행 문제를 TypeScript 로거로 전달하고 다시 도구로 전달해야 합니다.
6.  **버전 동기화:** 네이티브 CLI와 MCP 도구(TypeScript 패키지)는 같은 버전 번호를 가져야 합니다. 이 버전은 빌드 프로세스 중에 주입되어야 하며, 하드코딩되지 않아야 하지만 쉬운 개발을 허용해야 합니다(예: 빌드 시 스크립트가 버전을 교체하면서 Xcode에서 현재 소스를 사용).
7.  **네이티브 코드 품질:**
    *   CLI는 린터 문제가 없어야 합니다(Swift의 경우 SwiftLint).
    *   포매터를 적용해야 합니다(Swift의 경우 SwiftFormat).
    *   CLI는 분석기 문제를 표시하지 않아야 합니다.
8.  **JSON 통신:** 도구의 네이티브 바이너리 부분은 더 쉬운 파싱을 위해 TypeScript 서버에 JSON으로 통신하는 모드를 가져야 합니다. JSON 응답은 요청된 경우(예: 로그 레벨 전달로) 디버그 로그를 포함해야 합니다.
9.  **CLI 도움말 명령:** 바이너리는 `--help`에 대해 사용법과 모든 옵션을 설명하는 도움이 되는 명령으로 응답해야 합니다.
10. **인수 파싱 프레임워크:** 바이너리는 강력한 인수 파서 프레임워크(Swift의 경우 `swift-argument-parser`)를 사용해야 합니다.
11. **단일 파일 배포:** 네이티브 CLI의 경우, CLI를 직접 사용할 수 있는 최종 사용자를 위한 더 간단한 설치를 위해 가능하고 유익한 경우 단일, 정적으로 링크된 바이너리로 배포하는 옵션을 고려하십시오.

**VI. 릴리스 전 확인 규칙 (`scripts/prepare-release.js`)**

*   광범위한 테스트 스위트를 실행하는 `scripts/prepare-release.js`가 있습니다. 스크립트는 이러한 검사를 순차적으로 실행하고 첫 번째 실패에서 중지됩니다.

    **Git 및 버전 제어:**
    1.  현재 브랜치 확인(main 또는 지정된 릴리스 브랜치에 있지 않으면 경고).
    2.  커밋되지 않은 변경사항 확인.
    3.  origin/main(또는 지정된 릴리스 브랜치)와 동기화되었는지 확인.
    4.  버전 가용성 확인(버전이 이미 게시되지 않았는지 확인).
    5.  `package.json`과 `package-lock.json` 간의 버전 일관성.
    6.  **변경 로그 확인:** 현재 버전에 해당하는 변경 로그 항목 확인.

    **코드 품질 및 보안:**
    1.  종속성 설치 확인.
    2.  오래된 종속성 확인(경고만).
    3.  보안 감사(중요/높음 취약점에서 실패).
    4.  TypeScript 컴파일.
    5.  TypeScript 테스트.
    6.  TypeScript 선언 파일 생성.
    7.  빌드 폴더 삭제 및 패키지 캐시 재설정 후 빌드.
    8.  *네이티브 바이너리가 존재하는 경우:* Swift 분석.
    9.  *네이티브 바이너리가 존재하는 경우:* Swift 포맷팅(SwiftFormat).
    10. *네이티브 바이너리가 존재하는 경우:* Swift 린팅(SwiftLint).
    11. *네이티브 바이너리가 존재하는 경우:* Swift 테스트.
    12. 빌드 경고 없음.

    **바이너리 및 CLI 검증 (해당하는 경우):**
    13. *네이티브 바이너리가 존재하는 경우:* Swift CLI 명령 테스트(도움말, 버전 및 기타 주요 기능).
    14. *네이티브 바이너리가 존재하는 경우:* Swift CLI 오류 처리 테스트(잘못된 명령, 누락된 인수, 잘못된 윈도우 인덱스 등).
    15. *네이티브 바이너리가 존재하는 경우:* Swift CLI JSON 출력 검증.
    16. *네이티브 바이너리가 존재하는 경우:* 바이너리가 존재하고 실행 가능한지 확인.
    17. *네이티브 바이너리가 존재하는 경우:* 바이너리가 두 아키텍처(arm64 + x86_64, `lipo -info`로 확인 가능)를 모두 포함하는지 확인.
    18. *네이티브 바이너리가 존재하는 경우:* 바이너리가 `--help`에 올바르게 응답하는지 확인.

    **패키지 검증:**
    19. `package.json`의 필수 필드.
    20. 패키지 크기 확인(2MB 초과 시 경고, 구성 가능한 임계값).
    21. `postinstall`에서 실행 권한 확인(CLI가 있는 경우).
    22. 중요한 파일 포함(예: `dist/index.js`, 네이티브 바이너리 이름, `README.md`, `LICENSE`).
    23. MCP 서버 스모크 테스트(JSON-RPC 요청/응답).
    24. 전체 통합 테스트.

*   릴리스는 먼저 npm 레지스트리에 `beta` 태그로 수행되어 `npx [packageName]@beta install` 방법으로 테스트할 수 있습니다.