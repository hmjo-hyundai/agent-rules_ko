---
description: 새로운 패턴과 모범 사례를 기반으로 AI 어시스턴트 규칙을 지속적으로 개선하는 체계적인 접근법
globs: ""
alwaysApply: false
---

# AI 개발 규칙의 지속적인 개선 가이드

이 가이드는 개발 중 발견되는 새로운 패턴, 모범 사례, 그리고 교훈을 기반으로 AI 어시스턴트 규칙을 지속적으로 개선하는 체계적인 접근법을 제공합니다.

## 규칙 개선 트리거

### 언제 규칙을 생성하거나 업데이트해야 하는가

**새로운 규칙 생성 시점:**
- 새로운 기술/패턴이 3개 이상의 파일에서 사용될 때
- 공통 버그가 규칙으로 방지될 수 있을 때
- 코드 리뷰에서 반복적으로 같은 피드백이 언급될 때
- 새로운 보안 또는 성능 패턴이 나타날 때
- 복잡한 작업이 일관된 접근법을 필요로 할 때

**기존 규칙 업데이트 시점:**
- 코드베이스에 더 나은 예시가 존재할 때
- 추가 엣지 케이스가 발견될 때
- 관련 규칙들이 업데이트되었을 때
- 구현 세부사항이 변경되었을 때
- 사용자 피드백이 혼란을 나타낼 때

## 분석 프로세스

### 1. 패턴 인식

코드베이스에서 반복되는 패턴을 모니터링하세요:

```typescript
// 예시: 이 패턴이 반복적으로 나타나는 경우:
const data = await prisma.user.findMany({
  select: { id: true, email: true },
  where: { status: 'ACTIVE' }
});

// 다음 사항을 문서화하는 것을 고려하세요:
// - 표준 선택 필드
// - 공통 where 조건
// - 성능 최적화 패턴
```

### 2. 오류 패턴 분석

공통 실수와 그 해결책을 추적하세요:

```yaml
일반적인 오류: "연결 시간 초과"
근본 원인: 서비스 시작 후 전략적 지연 누락
해결책: 서비스 실행 후 5-10초 지연 추가
규칙 업데이트: 자동화 규칙에 타이밍 가이드라인 추가
```

### 3. 모범 사례 진화

새로운 모범 사례를 문서화하세요:

```markdown
## 이전 (기존 패턴)
- 직접 DOM 조작
- 오류 처리 없음
- 동기 작업

## 이후 (새로운 패턴)
- 프레임워크 메서드 사용
- 포괄적인 오류 처리
- 적절한 오류 경계가 있는 async/await
```

## 규칙 품질 프레임워크

### 구조 가이드라인

각 규칙은 다음 구조를 따라야 합니다:

```markdown
# 규칙 이름

## 목적
이 규칙이 달성하는 것에 대한 간략한 설명

## 적용 시점
- 특정 시나리오
- 트리거 조건
- 전제 조건

## 구현
### 기본 패턴
```code
// 최소한의 작동 예시
```

### 고급 패턴
```code
// 오류 처리가 포함된 복잡한 시나리오
```

## 일반적인 함정
- 알려진 문제
- 이를 피하는 방법

## 참고 자료
- 관련 규칙: [rule-name.md]
- 외부 문서: [링크]
```

### 품질 체크리스트

규칙을 게시하기 전에 다음을 확인하세요:

- [ ] **실행 가능**: 명확하고 구현 가능한 가이드 제공
- [ ] **구체적**: 모호한 권장사항 방지
- [ ] **테스트됨**: 예시가 작동하는 코드에서 나옴
- [ ] **완전함**: 일반적인 엣지 케이스 커버
- [ ] **최신**: 참고 자료가 최신 상태
- [ ] **연결됨**: 관련 규칙과 상호 참조

## 지속적인 개선 워크플로우

### 1. 수집 단계

**일일 개발**
- 반복되는 코드 패턴 기록
- 해결된 문제 문서화
- 도구 사용 패턴 추적

**주간 검토**
- 패턴을 위한 git 커밋 분석
- 디버깅 세션 검토
- 오류 로그 확인

### 2. 분석 단계

**패턴 추출**
```python
# 패턴 분석을 위한 의사 코드
patterns = analyze_codebase()
for pattern in patterns:
    if pattern.frequency >= 3 and not documented(pattern):
        create_rule_draft(pattern)
```

**영향 평가**
- 얼마나 많은 파일이 이익을 볼 것인가?
- 어떤 오류가 방지될 것인가?
- 얼마나 많은 시간이 절약될 것인가?

### 3. 문서화 단계

**규칙 생성 프로세스**
1. 예시가 포함된 초기 규칙 초안 작성
2. 기존 코드에서 규칙 테스트
3. 팀으로부터 피드백 받기
4. 정제 및 게시
5. 효과성 모니터링

### 4. 유지보수 단계

**정기 업데이트**
- 월별: 규칙 사용 검토
- 분기별: 주요 업데이트
- 연별: 사용 중단 검토

## 규칙 관리를 위한 메타 규칙

### 규칙 버전 관리

```yaml
rule_version: 1.2.0
last_updated: 2024-01-15
breaking_changes:
  - v1.0.0: 최초 릴리스
  - v1.1.0: 오류 처리 패턴 추가
  - v1.2.0: 새로운 프레임워크 버전에 맞춰 업데이트
```

### 사용 중단 프로세스

```markdown
## 사용 중단됨: 기존 패턴
**상태**: v2.0.0부터 사용 중단
**마이그레이션**: [new-pattern.md] 참조
**제거 날짜**: 2024-06-01

[참조용으로 보존된 원래 내용]
```

### 규칙 메트릭

규칙 효과성 추적:

```yaml
metrics:
  usage_count: 45
  error_prevention: 12개 버그 방지
  time_saved: 주당 약 3시간
  user_feedback: 4.2/5
```

## 예시: 자체 개선 규칙 시스템

### 자동화된 규칙 제안

```typescript
// 코드 패턴 모니터링
interface RuleSuggestion {
  pattern: string;
  frequency: number;
  files: string[];
  suggestedRule: string;
}

// 제안 생성
function analyzeForRules(codebase: Codebase): RuleSuggestion[] {
  // 구현
}
```

### 피드백 루프 통합

```yaml
# 프로젝트의 .cursor/rules/feedback.yaml에서
feedback_enabled: true
feedback_channel: "#ai-rules"
suggestion_threshold: 3
auto_create_draft: true
```

## 규칙 진화를 위한 모범 사례

### 1. 간단하게 시작
- 최소한의 실행 가능한 규칙으로 시작
- 실제 필요에 따라 복잡성 추가
- 과도한 엔지니어링 피하기

### 2. 실패로부터 배우기
- 작동하지 않은 것 문서화
- 실패 이유 이해
- 배운 교훈 공유

### 3. 기여 장려
- 개선 제안을 쉽게 만들기
- 새로운 규칙을 위한 템플릿 제공
- 기여자 인정

### 4. 영향 측정
- 전후 메트릭 추적
- 사용자 증언 수집
- 시간 절약 수치화

## 개발 워크플로우와의 통합

### Git 훅
```bash
#!/bin/bash
# 규칙 준수를 확인하는 pre-commit 훅
./scripts/check-rules.sh
```

### CI/CD 파이프라인
```yaml
# .github/workflows/rules.yml
name: Rule Compliance Check
on: [push, pull_request]
jobs:
  check-rules:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - run: npm run check:rules
```

### IDE 통합
```json
// .vscode/settings.json
{
  "cursor.rules.autoSuggest": true,
  "cursor.rules.path": ".cursor/rules",
  "cursor.rules.checkOnSave": true
}
```

## 결론

AI 개발 규칙의 지속적인 개선은 다음이 필요한 반복적인 프로세스입니다:
- 개발 패턴의 적극적인 모니터링
- 정기적인 분석 및 문서화
- 커뮤니티 피드백 및 협업
- 체계적인 유지보수 및 업데이트

이 가이드를 따라 팀은 코드베이스와 함께 진화하고 개발자 생산성을 지속적으로 향상시키는 살아있는 지식 베이스를 구축할 수 있습니다.